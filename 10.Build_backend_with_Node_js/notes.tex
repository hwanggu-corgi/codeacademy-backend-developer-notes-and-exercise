\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}
\usepackage[utf]{kotex}
\usepackage{hyperref}
\usepackage{soul}
\usepackage{cancel}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{Codeacademy}
\rhead{Notes}

\begin{document}
\title{Codeacademy Notes}

\section{Build a Back-End with Node/Express.js}
\subsection{Introduction}
\subsection{Node REPL}
\begin{itemize}
    \item Is an abbrebivation for Read-eval-print loop
    \item Node comes with built-in javascript REPL
    \item \texttt{.editor} goes into editor mode
    \begin{itemize}
        \item Use \texttt{CTRL + D} when ready to evaluate the input
    \end{itemize}
    \item A REPL can be extremely useful for performing calculations
    \item The Node environment contains a number of Node-specific \texttt{global}
    elements in addition to those built into the JavaScript language
    \begin{itemize}
        \item can be examined using command \texttt{console.log(global)}
    \end{itemize}
\end{itemize}

\subsection{Running a Program with Node}
\begin{itemize}
    \item Done using command \texttt{node myProgram.js}
    \item Javascript code is written to file \texttt{.js} extension
\end{itemize}

\subsection{Accessing the Process Object}
\begin{itemize}
    \item Node has a global \texttt{process} object with useful methods and information about the current process.
    \begin{itemize}
        \item \texttt{process.env} property is an object which stores and controls information about the environment in which the process is currently running
        \begin{itemize}
            \item \texttt{PWD} - holds a string with the directory where the current process is located
            \item \texttt{NODE\_ENV} - holds a value of either production or development

            \bigskip

            \underline{\textbf{Example}}

    \begin{lstlisting}
    if (process.env.NODE_ENV === 'development'){
        console.log('Testing! Testing! Does everything work?');
    }
    \end{lstlisting}

            \item \texttt{process.memoryUsage()} returns information on the CPU demands of the current process.
            \item \texttt{process.memoryUsage().heapUsed} return a number representing how many bytes of memory the current process is using.
        \end{itemize}
        \item \texttt{process.argv} property holds an array of command line values provided when the current process was initiated
        \begin{itemize}
            \item first element in the array is the absolute path to Node
            \item second element in the array is the path to the file that’s running
            \item following elements will be any command line arguments provided when the process was initiated (like C)!!!
        \end{itemize}

    \begin{lstlisting}
    node myProgram.js testing several features
    \end{lstlisting}

    \begin{lstlisting}
    console.log(process.argv[3]); // Prints 'several'
    \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsection{Core Modules and Local Modules}
\begin{itemize}
    \item \textbf{Modularity} is a software design technique where one program has distinct parts each providing a single piece of the overall functionality.
    \begin{itemize}
        \item Is essential when creating scalable programs
        \begin{itemize}
            \item incorporate libraries and frameworks and separate the program’s concerns into manageable chunks
        \end{itemize}
    \end{itemize}
    \item \textbf{Modules} come together to build a cohesive whole
    \begin{itemize}
        \item is imported using \texttt{require()}

    \begin{lstlisting}
    // Require in the 'events' core module:
    let events = require('events');
    \end{lstlisting}

        \item is exported using \texttt{module.exports}

    \begin{lstlisting}
    module.exports = class Dog {

        constructor(name) {
            this.name = name;
        }

        praise() {
            return `Good dog, ${this.name}!`;
        }
    };
    \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsection{Node Package Manager}
\begin{itemize}
    \item NPM, which stands for Node Package Manager
\end{itemize}

\subsection{Event-Driven Architecture}
\begin{itemize}
    \item Node is often described as having event-driven architecture
    \item Node provides an \texttt{EventEmitter} class which we can access by requiring in the events core module
    \begin{lstlisting}
    // Require in the 'events' core module
    let events = require('events');

    // Create an instance of the EventEmitter class
    let myEmitter = new events.EventEmitter();
    \end{lstlisting}
\end{itemize}

\subsection{Event-Driven Architecture}
\begin{itemize}
    \item Node is often described as having event-driven architecture.
    \begin{itemize}
        \item This feels so much like threaded programming
    \end{itemize}
    \item event emitter instance has an \texttt{.on()} method which assigns a listener callback function to a named event.
    \begin{itemize}
        \item first argument - the name of the event as a string
        \item second argument - the listener callback function
    \end{itemize}

    \begin{lstlisting}

    let newUserListener = (data) => {
        console.log(`We have a new user: ${data}.`);
    };

    // Assign the newUserListener function as the listener callback for 'new user' events
    myEmitter.on('new user', newUserListener)

    // Emit a 'new user' event
    myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
    \end{lstlisting}
\end{itemize}

\subsection{Asynchronous JavaScript with Node.js}
\begin{itemize}
    \item Node was designed to use an event loop like the one used in browser-based JavaScript execution
    \item The event-loop enables asynchronous actions to be handled in a non-blocking way.
    \begin{itemize}
        \item APIs trigger the subscription to and \ul{emitting of events to signal the completion of the operation}
    \end{itemize}

    \underline{\textbf{Example}}

    \bigskip

    \begin{lstlisting}
    let keepGoing = true;

    let callback = () => {
        keepGoing = false;
    };

    setTimeout(callback, 1000); // Run callback after 1000ms

    while(keepGoing === true) {
        console.log(`This is the song that never ends. Yes, it just goes on and on my friends. Some people started singing it, not knowing what it was, and they'll continue singing it forever just because...`)
    };
    \end{lstlisting}

    \begin{itemize}
        \item The while loop will continue forever
        \item Why? because no signal has been sent
        \item To resolve this issue, replace \texttt{setTimeout} with \texttt{setTimeInterval}
    \end{itemize}
    \item \texttt{Promise}, \texttt{async ... await}
    \begin{itemize}
        \item modern way of handling asynchronous tasks
    \end{itemize}
\end{itemize}

\subsection{Asynchronous Javascript - Introduction}
\begin{itemize}
    \item \textbf{asynchronous operation} is one that allows the computer to “move on” to other tasks while waiting for the asynchronous operation to complete.
\end{itemize}

\subsection{Asynchronous Javascript - What is a Promise?}

\begin{center}
\includegraphics[width=0.9\linewidth]{images/tutorial_2.png}
\end{center}

\begin{itemize}
    \item \textbf{Pending:} The initial state— the operation has not completed yet.
    \item \textbf{Fulfilled:} The initial state— the operation has not completed yet.
    \item \textbf{Rejected:} The initial state— the operation has not completed yet.
\end{itemize}

\subsection{Constructing a Promise Object}
\begin{itemize}
    \item use the \texttt{new} keyword and the \texttt{Promise} constructor method

    \begin{lstlisting}
    const executorFunction = (resolve, reject) => { };
    const myFirstPromise = new Promise(executorFunction);
    \end{lstlisting}

    \item \texttt{Promise} constructor method takes a function parameter called the
    \texttt{executor} function which runs automatically when the constructor is called

    \item The \texttt{executor} function has has two function parameters
    \begin{itemize}
        \item \texttt{resolve()}
        \begin{itemize}
            \item is a function with one arguement
            \item invoke causes the promise's status to change from \texttt{pending} to \texttt{fulfilled}
            \item sets promises' resolved value to be the arguement passed to \texttt{resolve}
        \end{itemize}
        \item \texttt{reject()}
        \begin{itemize}
            \item takes a reason or error as an argument
            \item invoke causes \texttt{reject()} to change the promise’s status from \texttt{pending} to \texttt{rejected}
        \end{itemize}
    \end{itemize}

    \bigskip

    \underline{\textbf{Example}}

    \begin{lstlisting}
    const executorFunction = (resolve, reject) => {
        if (someCondition) {
            resolve('I resolved!');
        } else {
            reject('I rejected!');
        }
    }
    const myFirstPromise = new Promise(executorFunction);
    \end{lstlisting}

\end{itemize}

\subsection{The Node setTimeout() Function}

\begin{center}
\includegraphics[width=0.9\linewidth]{images/tutorial_3.png}
\end{center}


\begin{itemize}

    \item Rather than constructing promises, you’ll be handling \texttt{Promise} objects returned to you as the result of an asynchronous operation
    \begin{itemize}
        \item It will start off pending but settle eventually.
    \end{itemize}

    \item \texttt{setTimeout()}
    \begin{itemize}
        \item Is a node API
        \item Has two parameters
        \begin{itemize}
            \item a callback function
            \item a delay in milliseconds.
        \end{itemize}

        \begin{lstlisting}
        const executorFunction = (resolve, reject) => {
            if (someCondition) {
                resolve('I resolved!');
            } else {
                reject('I rejected!');
            }
        }
        const myFirstPromise = new Promise(executorFunction);
        \end{lstlisting}

    \end{itemize}

    \item the embedded code will exectue after said time (not exactly at the time)
    \begin{itemize}
        \item because the function within is added to a line of code waiting to be run
    \end{itemize}
\end{itemize}

\subsection{Consuming Promises}
\begin{itemize}
    \item \texttt{.then()} is that it always returns a promise. We’ll return to this in more detail in a later exercise and explore why it’s so important.
    \item \texttt{.then()} takes two callback functions as arguements
    \begin{itemize}
        \item First argument - is the success handler
        \item Second argument - is the failure handler
    \end{itemize}
\end{itemize}

\subsection{The onFulfilled and onRejected Functions}

\subsection{Using catch() with Promises}
\begin{itemize}
    \item \texttt{separation of concerns} - one way to write cleaner code
    \item Javascript doesn't mind whitespace
    \item \texttt{.catch()} function takes only one argument, onRejected

    \bigskip

    \underline{\textbf{Example}}

    \begin{lstlisting}
    prom
    .then((resolvedValue) => {
        console.log(resolvedValue);
    })
    .catch((rejectionReason) => {
        console.log(rejectionReason);
    });
    \end{lstlisting}

\end{itemize}

\subsection{Chaining Multiple Promises}
\begin{itemize}
    \item \texttt{composition} - the process of chaining promises together
    \item Promise is designed with composition in mind

    \bigskip

    \underline{\textbf{Example}}

    \begin{lstlisting}
    firstPromiseFunction()
    .then((firstResolveVal) => {
        return secondPromiseFunction(firstResolveVal);
    })
    .then((secondResolveVal) => {
        console.log(secondResolveVal);
    });
    \end{lstlisting}

    \begin{itemize}
        \item We invoke a function \texttt{firstPromiseFunction()} which returns a promise.
        \item \texttt{.then()} is invoked with an anonymous function as the success handler
        \item Inside the success handler we return a new promise— the result of invoking a second function, \texttt{secondPromiseFunction()} with the first promise’s resolved value.
        \item second \texttt{.then()} is invoked to handle the logic for the second promise settling.
        \item Inside second \texttt{.then()}, we have a success handler which will log the second promise’s resolved value to the console.
    \end{itemize}
\end{itemize}

    \begin{lstlisting}
    const {checkInventory, processPayment, shipOrder} = require('./library.js');

    const order = {
        items: [['sunglasses', 1], ['bags', 2]],
        giftcardBalance: 79.82
    };

    checkInventory(order)
    .then((resolvedValueArray) => {
        // Write the correct return statement here:
        return processPayment(resolvedValueArray);
    })
    .then((resolvedValueArray) => {
        // Write the correct return statement here:
        return shipOrder(resolvedValueArray);
    })
    .then((successMessage) => {
        console.log(successMessage);
    })
    .catch((errorMessage) => {
        console.log(errorMessage);
    });

    \end{lstlisting}

\subsection{Avoiding Common Mistakes}
\begin{itemize}
    \item \textbf{Mistake 1:} Nesting promises instead of chaining them.
    \begin{itemize}
        \item Works fine
        \item Imagine if we are handling five or then promises
    \end{itemize}
    \begin{lstlisting}
    returnsFirstPromise()
    .then((firstResolveVal) => {
        return returnsSecondValue(firstResolveVal)
        .then((secondResolveVal) => {
            console.log(secondResolveVal);
        })
    })
    \end{lstlisting}

    \item \textbf{Mistake 2:} Forgetting to return a promise.
    \begin{itemize}
        \item
    \end{itemize}

    \begin{lstlisting}
    returnsFirstPromise()
    .then((firstResolveVal) => {
        returnsSecondValue(firstResolveVal)
    })
    .then((someVal) => {
        console.log(someVal);
    })
    \end{lstlisting}

    \begin{itemize}
        \item \texttt{returnsFirstPromise()} which returns a promise.
        \item invoke a second \texttt{.then()}. Since we didn’t return, this \texttt{.then()} is invoked on a promise with the \ul{same settled value} as the original promise
    \end{itemize}
\end{itemize}

\end{document}
