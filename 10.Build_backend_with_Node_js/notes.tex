\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}
\usepackage[utf]{kotex}
\usepackage{hyperref}
\usepackage{soul}
\usepackage{cancel}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{Codeacademy}
\rhead{Notes}

\begin{document}
\title{Codeacademy Notes}

\section{Build a Back-End with Node/Express.js}
\subsection{Introduction}
\subsection{Node REPL}
\begin{itemize}
    \item Is an abbrebivation for Read-eval-print loop
    \item Node comes with built-in javascript REPL
    \item \texttt{.editor} goes into editor mode
    \begin{itemize}
        \item Use \texttt{CTRL + D} when ready to evaluate the input
    \end{itemize}
    \item A REPL can be extremely useful for performing calculations
    \item The Node environment contains a number of Node-specific \texttt{global}
    elements in addition to those built into the JavaScript language
    \begin{itemize}
        \item can be examined using command \texttt{console.log(global)}
    \end{itemize}
\end{itemize}

\subsection{Running a Program with Node}
\begin{itemize}
    \item Done using command \texttt{node myProgram.js}
    \item Javascript code is written to file \texttt{.js} extension
\end{itemize}

\subsection{Accessing the Process Object}
\begin{itemize}
    \item Node has a global \texttt{process} object with useful methods and information about the current process.
    \begin{itemize}
        \item \texttt{process.env} property is an object which stores and controls information about the environment in which the process is currently running
        \begin{itemize}
            \item \texttt{PWD} - holds a string with the directory where the current process is located
            \item \texttt{NODE\_ENV} - holds a value of either production or development

            \bigskip

            \underline{\textbf{Example}}

    \begin{lstlisting}
    if (process.env.NODE_ENV === 'development'){
        console.log('Testing! Testing! Does everything work?');
    }
    \end{lstlisting}

            \item \texttt{process.memoryUsage()} returns information on the CPU demands of the current process.
            \item \texttt{process.memoryUsage().heapUsed} return a number representing how many bytes of memory the current process is using.
        \end{itemize}
        \item \texttt{process.argv} property holds an array of command line values provided when the current process was initiated
        \begin{itemize}
            \item first element in the array is the absolute path to Node
            \item second element in the array is the path to the file that’s running
            \item following elements will be any command line arguments provided when the process was initiated (like C)!!!
        \end{itemize}

    \begin{lstlisting}
    node myProgram.js testing several features
    \end{lstlisting}

    \begin{lstlisting}
    console.log(process.argv[3]); // Prints 'several'
    \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsection{Core Modules and Local Modules}
\begin{itemize}
    \item \textbf{Modularity} is a software design technique where one program has distinct parts each providing a single piece of the overall functionality.
    \begin{itemize}
        \item Is essential when creating scalable programs
        \begin{itemize}
            \item incorporate libraries and frameworks and separate the program’s concerns into manageable chunks
        \end{itemize}
    \end{itemize}
    \item \textbf{Modules} come together to build a cohesive whole
    \begin{itemize}
        \item is imported using \texttt{require()}

    \begin{lstlisting}
    // Require in the 'events' core module:
    let events = require('events');
    \end{lstlisting}

        \item is exported using \texttt{module.exports}

    \begin{lstlisting}
    module.exports = class Dog {

        constructor(name) {
            this.name = name;
        }

        praise() {
            return `Good dog, ${this.name}!`;
        }
    };
    \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsection{Node Package Manager}
\begin{itemize}
    \item NPM, which stands for Node Package Manager
\end{itemize}

\subsection{Event-Driven Architecture}
\begin{itemize}
    \item Node is often described as having event-driven architecture
    \item Node provides an \texttt{EventEmitter} class which we can access by requiring in the events core module
    \begin{lstlisting}
    // Require in the 'events' core module
    let events = require('events');

    // Create an instance of the EventEmitter class
    let myEmitter = new events.EventEmitter();
    \end{lstlisting}
\end{itemize}

\subsection{Event-Driven Architecture}
\begin{itemize}
    \item Node is often described as having event-driven architecture.
    \begin{itemize}
        \item This feels so much like threaded programming
    \end{itemize}
    \item event emitter instance has an \texttt{.on()} method which assigns a listener callback function to a named event.
    \begin{itemize}
        \item first argument - the name of the event as a string
        \item second argument - the listener callback function
    \end{itemize}

    \begin{lstlisting}

    let newUserListener = (data) => {
        console.log(`We have a new user: ${data}.`);
    };

    // Assign the newUserListener function as the listener callback for 'new user' events
    myEmitter.on('new user', newUserListener)

    // Emit a 'new user' event
    myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
    \end{lstlisting}
\end{itemize}

\subsection{Asynchronous JavaScript with Node.js}
\begin{itemize}
    \item Node was designed to use an event loop like the one used in browser-based JavaScript execution
    \item The event-loop enables asynchronous actions to be handled in a non-blocking way.
    \begin{itemize}
        \item APIs trigger the subscription to and \ul{emitting of events to signal the completion of the operation}
    \end{itemize}

    \underline{\textbf{Example}}

    \bigskip

    \begin{lstlisting}
    let keepGoing = true;

    let callback = () => {
        keepGoing = false;
    };

    setTimeout(callback, 1000); // Run callback after 1000ms

    while(keepGoing === true) {
        console.log(`This is the song that never ends. Yes, it just goes on and on my friends. Some people started singing it, not knowing what it was, and they'll continue singing it forever just because...`)
    };
    \end{lstlisting}

    \begin{itemize}
        \item The while loop will continue forever
        \item Why? because no signal has been sent
        \item To resolve this issue, replace \texttt{setTimeout} with \texttt{setTimeInterval}
    \end{itemize}
    \item \texttt{Promise}, \texttt{async ... await}
    \begin{itemize}
        \item modern way of handling asynchronous tasks
    \end{itemize}
\end{itemize}

\subsection{Asynchronous Javascript - Introduction}
\begin{itemize}
    \item \textbf{asynchronous operation} is one that allows the computer to “move on” to other tasks while waiting for the asynchronous operation to complete.
\end{itemize}

\subsection{Asynchronous Javascript - What is a Promise?}

\begin{center}
\includegraphics[width=0.9\linewidth]{images/tutorial_2.png}
\end{center}

\begin{itemize}
    \item \textbf{Pending:} The initial state— the operation has not completed yet.
    \item \textbf{Fulfilled:} The initial state— the operation has not completed yet.
    \item \textbf{Rejected:} The initial state— the operation has not completed yet.
\end{itemize}

\end{document}
